- react là 1 lib
- nextjs là 1 framework React
- Next.js = React + Routing + SSR + API + Tối ưu hoá → Dùng để xây web hiện đại, nhanh, SEO tốt, code gọn.

- lý do dùng nextJs
    + vì react flexible -> không có kiến trúc thống nhất - structure / router / manage state (người dùng reducer / người thì redux.. ) 
    -> nextJs ra đời như để tạo 1 khung chung -> chỉ cần code trong khung đó
    -> đồng thời nó cũng tối ưu tốt cho SEO 

- nextJs là 1 fullStack framework
    - nhưng ta dùng chính cho frontend -> chỉ hỗ trợ cơ bản về backend
    -> vì khi thêm code của bankend vào của frontend -> structure sẽ rất khó maintain + và không đảm bảo về tính an toàn
        -> ta dùng cho frontend là chính còn backend chỉ để hỗ trợ

- tính năng 
    - render
        + ssr
        + csr
        + ssg
        + isr
    - routing
        + routing theo cấu trúc file trong thư mục /app hoặc /pages -> không cần dùng react-router
    - API routes -> backend mini 
        + có thể tạo API ngay trong dự án nextJs 
        -> không dùng cho những dự án lớn -> như đã viết ở trên -> vì rất rối
        -> chỉ nên dùng thuần cho frontend
    - tối ưu hóa Built-in
    - middleWare của nextJs

- client side rendering - csr
    -> tức là render hoàn toàn ở trình duyệt
    (reactJs là 1 ví dụ điển hình cho csr)

    tổng quát
        - người dùng vào 1 trang web
        - server gửi về 1 html trống rỗng(rất ít nội dung) + 1 tệp js khá nặng
        - browser tải tệp js
        - js chạy trên trình duyệt -> gọi api lấy dữ liệu -> tự tạo ra các thẻ HTML trên màn hình
        -> ta hiểu đơn giản là việc render thực hiện ở phía browser(client) vì bản chất nó chỉ cầm 1 file html ít nội dụng
        còn lại tất cả các nội dung hiển thị... -> là do thằng js ở phía client gắn vào thẻ html để hiển thị
        - nhược điểm
            + SEO kém -> vì bot gg vào trang web chỉ thấy 1 html trắng
            + tải lần đầu chậm -> vì phải đợi các file JS tải xong
        - ưu điểm
            -> SPA -> sau lần đầu tải -> việc vận hành trang rất mượt mà -> vì không cần tải lại toàn bộ trang 
                -> những lần sau nó chỉ thay đổi việc render các component 

    - ví dụ trực tiếp ở React
        Browser tải 1 file HTML rỗng (chỉ có <div id="root"></div>).
        Browser tải file JavaScript (bundle của React).
        React chạy và tự render UI trong browser.
        Nếu cần data → dùng useEffect để gọi API từ client → update state → re-render.
        
        - Ví dụ dễ hiểu
            Giống như bạn mua đồ IKEA:
            Nhà sản xuất chỉ đưa vật liệu + hướng dẫn → bạn tự lắp ghép.
            React cũng vậy:
            Server chỉ đưa bộ khung HTML rỗng + file JS → trình duyệt tự render giao diện.

- server side rendering - csr
    Server render HTML trước, client chỉ tải JS để “hydrate”.

    - Luồng chạy:
        User → server
        Server render React thành HTML đầy đủ
        Browser nhận HTML → hiển thị ngay
        JavaScript chạy lại để hydrate (thêm event listeners)
    ➕ Ưu điểm:
        SEO tốt.
        First paint nhanh.
    ➖ Nhược điểm:
    Server phải render liên tục → tốn tài nguyên.
    Tương tác ban đầu chậm hơn CSR do hydration.
        
        1. Cơ chế hoạt động chi tiết (Under the Hood)
        - Khác với các trang web tĩnh (Static - file HTML có sẵn), SSR là quá trình "Nấu ăn theo yêu cầu".
            * Khi người dùng truy cập uRl.com/profile/user123:
                + Request (Yêu cầu): Trình duyệt gửi yêu cầu đến Server.
                + Execution (Thực thi): Server nhận yêu cầu, nhưng chưa có file HTML nào cả. Nó bắt đầu chạy bộ mã (Node.js, PHP, Java...).
                + Data Fetching (Lấy dữ liệu - Bước quan trọng nhất):
                + Server kết nối tới Database (Cơ sở dữ liệu) hoặc gọi API bên thứ 3.
            Ví dụ: "Tìm trong bảng User xem ông 'user123' tên là gì, avatar link nào".
                + Server phải đợi cho đến khi dữ liệu này trả về xong (Blocking).
                + Templating (Trộn nội dung): Server lấy dữ liệu vừa tìm được, "nhồi" vào khung xương HTML (Template).
                + Biến {{username}} được thay bằng "Nguyễn Văn A".
            -> Response (Phản hồi): Server đóng gói file HTML hoàn chỉnh này và gửi về trình duyệt.
        Điểm mấu chốt: Quá trình từ bước 2 đến bước 5 diễn ra mỗi lần có người truy cập. 1.000 người vào cùng lúc => Server phải "nấu" 1.000 lần (trừ khi có Caching).

    - Tổng kết: Bản chất cốt lõi của SSR
        + Chuyển dịch gánh nặng: Lấy bớt việc xử lý (render) từ máy người dùng (Client) vác về máy chủ (Server) làm.
        + Ưu tiên nội dung: Đảm bảo người dùng và Google Bot nhìn thấy nội dung quan trọng nhất sớm nhất có thể.
        + Đánh đổi: Chấp nhận tốn tài nguyên Server để đổi lấy điểm SEO và trải nghiệm hiển thị ban đầu tốt hơn.

    cách rendering của nextJs
        + React = chỉ CSR
        + Next.js = CSR + SSR + SSG + ISR + Streaming + Server Component

    Kỹ thuật	        Thời điểm render	     Dữ liệu	                Ví dụ thực tế
    CSR (React)	        Tại trình duyệt	        Lấy sau khi load trang	    Dashboard quản trị (Admin), Game.
    SSG	                Lúc Build (Deploy)	    Cũ (Tĩnh)	                Trang Landing Page, Điều khoản sử dụng.
    ISR	                Lúc Build + Định kỳ	    Cũ, nhưng được làm mới	    Danh sách sản phẩm TMĐT (giá không đổi từng giây).
    SSR	                Mỗi Request	            Mới nhất (Real-time)	    Newsfeed Facebook cá nhân hóa.
    Server Components	Tại Server (kết hợp)	Mới nhất	                Layout chính, Bài viết Blog (Next.js 13+).
    Streaming	        Song song (Từng phần)	Mới nhất (Không chặn)	    Trang chi tiết sản phẩm (Hình ảnh hiện
    

    ví dụ:
    Luồng đi của Next.js hiện đại
        + Khi bạn dùng Next.js (App Router), quy trình thực tế sẽ là sự pha trộn tinh tế:
        + Request: User vào trang web.
        + Server Component (SSR + Streaming): Server bắt đầu render bộ khung. Phần nào xong gửi về trước (Header/Nav). Phần nào nặng (List sản phẩm) thì gửi Loading state.
        + Client Component (Hydration): Trình duyệt nhận HTML, hiển thị ra. Sau đó tải JS cho các nút bấm, thanh tìm kiếm (Client Component) để chúng hoạt động.
        + Data Fetching: Trong quá trình này, Server Component có thể tự lấy dữ liệu trực tiếp từ DB mà không cần lộ API ra ngoài.
        + Đó là lý do tại sao Next.js được gọi là Meta-framework: Nó không bắt bạn chọn 1 cách, nó cho phép bạn trộn tất cả các cách trên trong cùng một trang web để đạt hiệu suất tối đa.
    Ví dụ dễ hình dung
        Giống như bạn đi ăn lẩu:
        Nhà hàng mang nồi + nước trước → (Layout + Header)
        Sau đó mang rau + mì → (Các component nhẹ)
        Thịt bò thì lâu hơn, nên họ đưa đĩa rau miễn phí để bạn đỡ đói trước → (Loading component)
        Khi thịt bò xong → họ mang ra → (streaming nội dung thật)
    
    - Client Component (Hydration)
    - Data Fetching (Server tự lấy dữ liệu)


- kiến thức trong vid
    - client component -> những component render ở phía client
    - server component -> những component render ở phía server
    - hybrid app
    - khi nào sử dụng ssr - csr -> kết hợp sao cho hiệu quả trong nextJs
        + những dữ liệu hiển thị nặng - tĩnh - ít khi thay đổi -> ném cho thg server làm
        + những cái hay thay đổi -> ném thg client làm
        ví dụ:
            - khi ta vào shoppee
            + reload 1 trang sản phẩm
            + ta sẽ thấy header và footer hiện luôn rồi
            + mà những mục như sản phẩm đã xem / bình luận thì đang load
            -> những cái mà không hay thay đổi -> ta dùng ssr -> nhanh vì không phải đợi load cả file js
            -> hay thay đổi -> ta phải dùng csr vì chỉ client mới biết là thay đổi cái gì -> thay đổi luôn ở client
                - nếu ta để những cái hay thay đổi ở ssr -> mỗi lần thay đổi lại gửi yêu cầu về server - server render rồi trả lại -> hiệu năng sẽ kh bằng render luôn ở client 
        -> dữ liệu tính -> ssr - dữ liệu động -> csr

    - file-system based routing - *dựa vào các tên file bắt buộc
        + Route = một folder + file page.tsx
        | Vai trò                    | Tên file bắt buộc |
        | -------------------------- | ----------------- |
        | Nội dung trang             | `page.tsx`        |
        | Layout của segment         | `layout.tsx`      |
        | Loading UI                 | `loading.tsx`     |
        | Error UI                   | `error.tsx`       |
        | 404 của segment            | `not-found.tsx`   |
        | Template (remount mỗi lần) | `template.tsx`    |

    - 'use client' -> là 1 chỉ thị (directive) của React/ nextJs
        tác dụng:
            - khi đặt ở đầu file component -> bạn đang tuyên bố với complier rằng:
            => component này và tất cả các component con được import vào nó sẽ chạy ở phía client
        lý do cần:
        + trong app router -> mặc định mọi component đều chạy trên server -> chúng chỉ render trên server và gửi html về browser (không gửi kèm js và logic react)
            -> vì thế use client như  cách bật lại các tính năng react truyền thống
            
            Tính năng	    Server Component (Mặc định)	                Client Component (use client)
            Nơi chạy	    Chỉ trên Server.	                        Render trước trên Server (HTML), sau đó Hydrate (gắn sự kiện) trên Browser.
            Dữ liệu	        Truy cập trực tiếp Database, File system.	Phải gọi API để lấy dữ liệu.
            React Hooks	    ❌ Không (useState, useEffect, v.v).	    ✅ Có thể sử dụng tất cả Hooks.
            Sự kiện	        ❌ Không (onClick, onChange).	        ✅ Có thể lắng nghe sự kiện người dùng.
            Bundle Size	    0KB (Không gửi code JS về client).	        Tăng kích thước file JS tải xuống.
        note:
            + ta hiểu khi gặp use client ở 1 nhánh nào đó -> nó sẽ đánh dấu cả nhánh đó là client boundary
            -> những component được import vào mặc dù không dùng use client cũng sẽ bị coi là client component
                -> chỉ dùng use client xuống leaf branch - những phần nhỏ nhất cầ tương tác

    - Link 
        - tính năng 
            + chuyển trang mà không tải lại toàn bộ trang (SPA feel)
            + *prefetching: ..
            + SEO -> nó vẫn render ra thẻ a thật sự trong HTML -> giúp gg hiểu bot hiểu ctruc trang tốt hơn  

    - useRouter -> là 1 hook cho phép điều hướng trang bằng js logic 
        -> sử dụng nó khi hành động chuyển trang không phải do ng dùng bấm trực tiếp vào 1 liên kết và do kết quả của 1 qtrinh xử lý

        - Các phương thức chính:
            router.push(href): Chuyển trang và lưu vào lịch sử (người dùng có thể bấm nút Back để quay lại).
            router.replace(href): Chuyển trang nhưng không lưu vào lịch sử (thay thế trang hiện tại, bấm Back sẽ không quay lại trang vừa rồi).
            router.back(): Quay lại trang trước.
            router.refresh(): Làm mới lại dữ liệu của Server Component hiện tại mà không mất state của Client (Tính năng đặc biệt của App Router).

        Tiêu chí,           <Link>,                                                 useRouter
        Cách dùng,          Dùng như thẻ HTML trong JSX.,                           Dùng trong hàm xử lý sự kiện (Event Handlers).
        Loại Component,     Dùng được ở cả Server & Client Component.,              Chỉ dùng được trong Client Component.
        SEO,                Tốt (Render ra thẻ <a>).,                               Kém (Không tạo ra liên kết ngữ nghĩa).
        Prefetching,        Tự động (Mặc định là true).,                            Không tự động (Phải dùng router.prefetch thủ công nếu muốn).
        Trường hợp dùng,    "Menu, danh sách bài viết, footer, link nội bộ.",       "Sau khi submit form, redirect sau bộ đếm giờ, logic phức tạp."
                            -> tạo 1 liên kết mà người dùng nhìn thấy và              -> khi cần chuyển trang dựa trên logic
                            bấm chuyển trang ngay lập tức                           -> ví dụ bấm nút này thì sẽ tự động chuyển trang..

    - Layout 
        giới thiệu:
            - nếu page.tsx là nội dung chính thay đổi liên tục -> layout.tsx là 1 khung cố định bao quanh nội dung Đó
        chi tiết
            - layout là 1 UI giao diện được chia sẻ giữa nhiều routes
            - *khi người dùng chuyển trang -> layout không bị render lại mà cái thay đổi chỉ là page.tsx
        phân loại: 2 loại chính
        - root layout
            + file: app/layout/tsx
            + vai trò: đây là 1 layout cấp cao nhất -> bao trùm toàn bộ ứng dụng
            + Ứng dụng: Thường dùng để đặt Navbar, Footer toàn trang, cấu hình Font chữ, hoặc các Context Provider (Theme, Authen).
        - nested layout
            + vị trí: layout.tsx nằm trong các thư mục con (ví dụ: app/dashboard/layout.tsx)
            + vai trò: layout đó sẽ chỉ áp dụng cho thư mục và các thư mục con của nó - nó vẫn sẽ bị bao bởi thằng rootlayout
            + Nhiệm vụ: Tạo ra các giao diện phụ. Ví dụ trang Dashboard cần có một Sidebar riêng mà trang Trang chủ không có.

            app/
            ├── layout.tsx      (Root Layout: Có Navbar chính)
            ├── page.tsx        (Trang chủ)
            └── dashboard/
                ├── layout.tsx  (Dashboard Layout: Có Sidebar admin)
                └── page.tsx    (Trang thống kê)

            Khi người dùng vào /dashboard: Next.js sẽ lồng ghép như sau: Root Layout -> chứa Dashboard Layout -> chứa Dashboard Page.

        - cơ chế hoạt động
            - layout thực chất là 1 react component nhận prop children
                + children chính là các file page.tsx đang được hiển thị
                + ta có thể chèn các phần cố định xung quanh children (sidebar / header/ footer...)
            -> *khi ta chuyển page -> Layout sẽ kh bị re-render mà nó chỉ thay đổi thg page thôi        
        - Ví dụ tổng hợp luồng đi:
            + Giả sử bạn có cấu trúc: app/shop/layout.tsx và app/shop/page.tsx.
            + Người dùng truy cập /shop.
            + Next.js render Root Layout.
            + Bên trong children của Root Layout, nó render Shop Layout.
            + Bên trong children của Shop Layout, nó render Shop Page.
            + Nếu người dùng bấm link sang /shop/shoes:
            + Root Layout: Giữ nguyên (Không render lại).
            + Shop Layout: Giữ nguyên (Sidebar shop không load lại).
            + Shop Page: Bị hủy và thay thế bằng nội dung của trang /shoes.
    - fetching data trong nextJs
Ví dụ:
    note:
    - ts check type dựa vào file env.d.ts
    - css module
    - react bootstrap